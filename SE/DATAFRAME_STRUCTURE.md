# DataFrame Structure Documentation

## Overview

This document explains how user data is stored in the SecureSwipe AI system. The system uses a **two-part storage approach** that separates user metadata from face recognition data.

## Storage Architecture

### 1. User Metadata DataFrame (`data/users.csv`)

**Purpose**: Stores user information that can be easily queried and displayed.

**Columns**:
- `user_id` (string): Unique identifier for each user (e.g., 'user-abc123')
- `university_id` (string): Student/Staff ID (e.g., '900428564')
- `name` (string): Full name of the user
- `email` (string): Email address
- `balance` (float): **Meal swipes count** (default: 8 for new users)
- `registered_faces` (int): Number of face embeddings registered for this user
- `role` (string): 'user' or 'admin'
- `created_at` (string): ISO timestamp of registration

**Example Entry**:
```csv
user_id,university_id,name,email,balance,registered_faces,role,created_at
user-639b549f,900428564,Taha Sarwat,sarwt01@pfw.edu,6,4,user,2025-10-31T23:16:09.283953
```

### 2. Face Embeddings Storage (`data/faces.pkl`)

**Purpose**: Stores face recognition embeddings (mathematical representations of faces).

**Format**: Python dictionary (pickle file)
```python
{
    'user-abc123': [embedding1, embedding2, embedding3],  # List of numpy arrays
    'user-xyz789': [embedding1, embedding2, embedding3]
}
```

**Why Separate Storage?**
- **Embeddings are numpy arrays** (typically 128 dimensions for Facenet model)
- **Cannot be stored in CSV** - numpy arrays don't serialize well in CSV format
- **Efficient storage** - Only mathematical representations, not raw images
- **Best practice** - Separating metadata from ML model data

**What are Embeddings?**
- Embeddings are numerical vectors that represent facial features
- Generated by DeepFace (Facenet model) from face images
- Used for face recognition by comparing similarity scores
- Each user typically has 3-5 embeddings (from different angle photos)

### 3. Transactions DataFrame (`data/transactions.csv`)

**Purpose**: Stores transaction history for audit and tracking.

**Columns**:
- `transaction_id`: Unique transaction identifier
- `user_id`: Links to users DataFrame
- `university_id`: For quick lookup
- `transaction_type`: 'meal_swipe', 'initial_balance', 'admin_added', etc.
- `amount`: Change in balance (+ or -)
- `balance_after`: Balance after transaction
- `timestamp`: When transaction occurred
- `status`: 'completed', 'failed', etc.

## Data Flow

### Registration Process

1. User provides: Name, University ID, Email, 3 face images
2. System extracts embeddings from each image using DeepFace
3. **DataFrame entry created** with user metadata (balance = 8 by default)
4. **Embeddings stored** in pickle file linked by `user_id`
5. Initial balance transaction recorded

### Recognition Process

1. User's face is captured via camera
2. System extracts embedding from the image
3. **Loads embeddings** from pickle file
4. Compares new embedding with all stored embeddings using cosine similarity
5. If match found (similarity > 0.5), retrieves user info from **DataFrame**
6. Grants access and deducts meal swipe from `balance` field

### Meal Swipe Deduction

1. User recognized and authenticated
2. System finds user in DataFrame by `user_id`
3. Decrements `balance` field by 1
4. Creates transaction record
5. Saves DataFrame to CSV

## Key Design Decisions

### ❌ Why NOT Store Images in DataFrame?
- **File size**: Images are large (hundreds of KB to MB each)
- **CSV limitation**: Cannot store binary image data efficiently
- **Unnecessary**: We only need embeddings for recognition, not raw images

### ❌ Why NOT Store Embeddings in DataFrame?
- **Data type**: Embeddings are numpy arrays (128+ dimensions)
- **CSV incompatibility**: Arrays don't serialize well in CSV
- **Performance**: Loading/saving would be slow and inefficient
- **Best practice**: ML model data should be separate from metadata

### ✅ Why Current Approach Works Best?
- **Efficient**: Metadata in CSV (fast queries, human-readable)
- **Scalable**: Embeddings in pickle (efficient binary storage)
- **Maintainable**: Clear separation of concerns
- **Standard**: Common pattern in ML applications

## Helper Functions

The codebase includes helper functions for managing the DataFrame:

- `init_dataframes()`: Initialize or load user and transaction DataFrames
- `save_dataframes()`: Save DataFrames to CSV files
- `init_face_embeddings()`: Initialize face embeddings storage
- `save_face_embeddings()`: Save embeddings to pickle file
- `get_user_by_id()`: Retrieve user by user_id
- `get_user_by_university_id()`: Retrieve user by university_id
- `update_user_balance()`: Update meal swipe balance

## Default Values

- **Default Meal Swipes**: 8 (defined as `DEFAULT_MEAL_SWIPES` constant)
- **Face Recognition Threshold**: 0.5 (50% similarity required)
- **Minimum Registration Images**: 3

## File Locations

```
data/
├── users.csv          # User metadata DataFrame
├── transactions.csv   # Transaction history DataFrame
└── faces.pkl          # Face embeddings (binary pickle file)
```

## Summary

**The DataFrame stores**:
- ✅ Name
- ✅ ID (university_id)
- ✅ Email
- ✅ Meal Swipes Count (balance)

**The DataFrame does NOT store**:
- ❌ Raw images (too large, unnecessary)
- ❌ Face embeddings (numpy arrays, stored in pickle file)

**This separation is intentional and follows best practices for ML applications!**

